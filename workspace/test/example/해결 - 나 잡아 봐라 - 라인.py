"""
문제
연인 코니와 브라운은 광활한 들판에서 ‘나 잡아 봐라’ 게임을 한다. 이 게임은 브라운이 코니를 잡거나, 코니가 너무 멀리 달아나면 끝난다. 게임이 끝나는데 걸리는 최소 시간을 구하시오.

조건
코니는 처음 위치 C에서 1초 후 1만큼 움직이고, 이후에는 가속이 붙어 매 초마다 이전 이동 거리 + 1만큼 움직인다. 즉 시간에 따른 코니의 위치는 C, C + 1, C + 3, C + 6, …이다.
브라운은 현재 위치 B에서 다음 순간 B – 1, B + 1, 2 * B 중 하나로 움직일 수 있다.
코니와 브라운의 위치 p는 조건 0 <= x <= 200,000을 만족한다.
브라운은 범위를 벗어나는 위치로는 이동할 수 없고, 코니가 범위를 벗어나면 게임이 끝난다.

입력 형식
표준 입력의 첫 줄에 코니의 위치 C와 브라운의 위치 B를 공백으로 구분하여 순서대로 읽는다.

출력 형식
브라운이 코니를 잡을 수 있는 최소시간 N초를 표준 출력한다. 단 브라운이 코니를 잡지 못한 경우에는 -1을 출력한다.

예제
입력: 11 2

출력: 5

코니의 위치: 11 → 12 → 14 → 17 → 21 → 26

브라운의 위치: 2 → 3 → 6 → 12 → 13 → 26

브라운은 코니를 5초 만에 잡을 수 있다.
"""

# 나름 맞다고 생각함
# 세 가지 케이스 (11, 2):5, (11, 1):6, (6, 3):4에 대해서 정답
# 비슷한 문제인 백준 1697에 대하여 일부 수정 후 정답

# odd & even
# time이 홀수와 짝수인 경우를 나눠서 생각하자.
# 브라운이 t = x일 때, 갈 수 있는 곳은 t= x+1일 때 갈 수 있다고 할 수 없지만,
# t = x+2일 때, 현재 위치에서 +1, -1 하는 것으로 갈 수 있다고 보장된다.

# old & new
# 할 때마다 돌리면 20만 * 최대 정답값 정도 시간이 나오므로
# 모든 경우에 대해서 하지말고 새로 추가 된 값에 대해서만 실행

cony, brown = map(int, input().split())
time = 0

odd = set()
even = {brown}
odd_new = set()
even_new = {brown}

while cony <= 200000:
    now, nxt, old, new \
        = (odd, even, odd_new, even_new) if time % 2 else (even, odd, even_new, odd_new)

    if cony in now:
        break

    for i in old:
        if i + 1 not in nxt and i < 200000:
            nxt.add(i + 1)
            new.add(i + 1)
        if i - 1 not in nxt and i > 0:
            nxt.add(i - 1)
            new.add(i - 1)
        if i * 2 not in nxt and i <= 100000:
            nxt.add(i * 2)
            new.add(i * 2)
    old.clear()

    time += 1
    cony += time

ans = time if cony <= 200000 else -1
print(ans)
